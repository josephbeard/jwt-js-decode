{"version":3,"file":"jwt-js-decode.es6.js","sources":["../src/jwt-js-decode.ts"],"sourcesContent":["import pako from \"pako\";\r\nimport crypto from \"crypto\";\r\n/*\r\nbrowserify\r\nimport { createHmac, createSign, createVerify } from \"crypto-browserify\";\r\n\r\nnode.js\r\nimport { createHmac, createSign, createVerify } from \"crypto\";\r\n*/\r\nexport const webCrypto = typeof window === \"object\" && (window.crypto || window['msCrypto']);\r\nexport const webCryptoSubtle = webCrypto && (webCrypto.subtle ||  webCrypto['webkitSubtle'] || webCrypto['Subtle']);\r\n\r\nexport const UNSUPPORTED_ALGORITHM = 'Unsupported algorithm name specified! Supported algorithms: \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\" and \"none\".';\r\nexport const ILLEGAL_ARGUMENT = 'Illegal argument specified!';\r\n\r\n\r\n/**\r\n * Pako 1.0.6 has 'from' property which is not included in current version of typeDef @types/pako@1.0.0\r\n *\r\n * @hidden\r\n */\r\ndeclare namespace Pako {\r\n    export interface DeflateOptions {\r\n        raw?: boolean;\r\n        from?: string;\r\n        to?: string;\r\n    }\r\n\r\n    export interface InflateOptions {\r\n        raw?: boolean;\r\n        from?: string;\r\n        to?: string;\r\n    }\r\n}\r\n\r\n/**\r\n * Class for creating a JwtSplit object with three parts of JWT Token as strings\r\n *\r\n * @class  JwtSplit\r\n */\r\nexport class JwtSplit {\r\n    /**\r\n     * Header (first) part of JWT Token\r\n     *\r\n     * @name  header\r\n     * @type {string}\r\n     */\r\n    header: string;\r\n\r\n    /**\r\n     * Payload (second) part of JWT Token\r\n     *\r\n     * @name  payload\r\n     * @type {string}\r\n     */\r\n    payload: string;\r\n\r\n    /**\r\n     * Signature (third) part of JWT Token\r\n     *\r\n     * @name  signature\r\n     * @type {string}\r\n     */\r\n    signature: string;\r\n\r\n    constructor(str: string) {\r\n        if (typeof str !== 'string') {\r\n            throw new Error(ILLEGAL_ARGUMENT);\r\n        }\r\n\r\n        const jwtArr = str.split('.');\r\n        if (jwtArr.length !== 3) {\r\n            throw new Error(ILLEGAL_ARGUMENT);\r\n        }\r\n\r\n        const [header, payload, signature] = jwtArr;\r\n        this.header = header;\r\n        this.payload = payload;\r\n        this.signature = signature;\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.header + '.' + this.payload + '.' + this.signature\r\n    }\r\n}\r\n\r\n/** JwtPart interface basically object type definition used as a placeholder */\r\ninterface JwtPart {\r\n    [key: string]: any\r\n}\r\n\r\n/**\r\n * Class for creating a JwtDecode object with three parts of JWT Token, header and payload decoded and parsed, signature in initial form\r\n *\r\n * @class  JwtDecode\r\n */\r\nexport class JwtDecode {\r\n    /**\r\n     * Header (first) part of JWT Token\r\n     *\r\n     * @name  header\r\n     * @type {JwtPart}\r\n     */\r\n    public header: JwtPart = {};\r\n\r\n    /**\r\n     * Payload (second) part of JWT Token\r\n     *\r\n     * @name  payload\r\n     * @type {JwtPart}\r\n     */\r\n    public payload: JwtPart = {};\r\n\r\n    /**\r\n     * Signature (third) part of JWT Token\r\n     *\r\n     * @name  signature\r\n     * @type {string}\r\n     */\r\n    public signature: string = '';\r\n\r\n    constructor(str: string) {\r\n        if (typeof str !== 'string') {\r\n            throw new Error(ILLEGAL_ARGUMENT);\r\n        }\r\n        const jwtObj: JwtSplit = jwtSplit(str);\r\n        if (jwtObj) {\r\n            this.header = jwtObj.header ? s2J(bu2s(jwtObj.header)) : {};\r\n            this.payload = jwtObj.payload ? (isGzip(this.header) ? s2J(zbu2s(jwtObj.payload)) : s2J(bu2s(jwtObj.payload))) : {};\r\n            this.signature = jwtObj.signature || '';\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        return s2bu(JSON.stringify(this.header)) + '.' + (isGzip(this.header) ? s2zbu(JSON.stringify(this.payload)) : s2bu(JSON.stringify(this.payload))) + '.' + this.signature\r\n    }\r\n}\r\n/**\r\n * Converts string to base64 string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function s2J(str: string): any {\r\n    try{\r\n        return JSON.parse(str);\r\n    } catch(e) {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Converts string to base64 string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function b2s(str: string): string {\r\n    try{\r\n        if(typeof window === 'object' && typeof window.atob === 'function') {\r\n            return window.atob(str);\r\n        } else if(typeof Buffer !== 'undefined') {\r\n            return Buffer.from(str, 'base64').toString('binary')\r\n        } else throw new Error(ILLEGAL_ARGUMENT);\r\n    } catch(e) {\r\n        throw new Error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Converts base64 string to base64url string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64url string\r\n */\r\nexport function b2bu(str: string): string {\r\n    if ((typeof str !== 'string') || (str.length % 4 !== 0)) {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    return str\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n        .replace(/=/g, '');\r\n}\r\n\r\n/**\r\n *\r\n * Converts base64url string to base64 string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64 string\r\n */\r\nexport function bu2b(str: string): string {\r\n    if ((typeof str !== 'string') || (str.length % 4 === 1)) {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    for (; (str.length % 4 !== 0);) {\r\n        str += '=';\r\n    }\r\n    return str\r\n        .replace(/\\-/g, '+')\r\n        .replace(/_/g, '/');\r\n}\r\n\r\n/**\r\n * Converts base64url string to string\r\n *\r\n * @param {string} str - base64url string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function bu2s(str: string): string {\r\n    return b2s(bu2b(str));\r\n}\r\n\r\n/**\r\n * Check if header has zip property (and it is equal to 'GZIP', ignorecase)\r\n *\r\n * @param {string} header - object to check\r\n *\r\n * @returns {boolean} does it have gzip in zip property\r\n */\r\nexport function isGzip(header: JwtPart): boolean {\r\n    return typeof header === 'object' && typeof header.zip === 'string' && header.zip.toUpperCase() === 'GZIP'\r\n}\r\n\r\n/**\r\n * Decode jwtToken header and payload\r\n *\r\n * @param {string} str - data string to decode\r\n *\r\n * @returns {JwtDecode} object with decoded header and body, and signature untouched\r\n */\r\nexport function jwtDecode(str: string): JwtDecode {\r\n    return new JwtDecode(str);\r\n}\r\n\r\n/**\r\n * Split jwtToken into object {header, payload, signature}\r\n *\r\n * @param {string} str - data string to split\r\n *\r\n * @returns {JwtSplit} jwt split object of three strings\r\n */\r\nexport function jwtSplit(str: string): JwtSplit {\r\n    return new JwtSplit(str);\r\n}\r\n\r\n/**\r\n * Converts base64 string to string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64 string\r\n */\r\nexport function s2b(str: string): string {\r\n    try{\r\n        if(typeof window === 'object' && typeof window.atob === 'function') {\r\n            return window.btoa(str);\r\n        } else if(typeof Buffer !== 'undefined') {\r\n            return Buffer.from(str).toString('base64');\r\n        } else throw new Error(ILLEGAL_ARGUMENT);\r\n    } catch(e) {\r\n        throw new Error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Converts string to base64url string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} base64url string\r\n */\r\nexport function s2bu(str: string): string {\r\n    return b2bu(s2b(str));\r\n}\r\n\r\n/**\r\n * Gzip and encode data string to base64url string\r\n *\r\n * @param {string} str - data string to encode\r\n *\r\n * @returns {string} base64url string\r\n */\r\nexport function s2zbu(str: string): string {\r\n    return s2bu(zip(str));\r\n}\r\n\r\n/**\r\n * Converts from gzip data string to string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function unzip(str: string): string {\r\n    if (typeof str !== 'string') {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    return pako.inflate(str, {\r\n        raw: false,\r\n        from: 'string',\r\n        to: 'string'\r\n    } as Pako.InflateOptions & { to: 'string' });\r\n}\r\n\r\n/**\r\n * Decode from base64url and unzip data string\r\n *\r\n * @param {string} str - data string to decode\r\n *\r\n * @returns {string} decoded data string\r\n */\r\nexport function zbu2s(str: string): string {\r\n    return unzip(bu2s(str));\r\n}\r\n\r\n/**\r\n * Converts string to gzip data string\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {string} gzip data string\r\n */\r\nexport function zip(str: string): string {\r\n    if (typeof str !== 'string') {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n\r\n    return pako.deflate(str, {\r\n        raw: false,\r\n        from: 'string',\r\n        to: 'string'\r\n    } as Pako.DeflateOptions & { to: 'string' });\r\n}\r\n\r\n/**\r\n * Converts string to ArrayBuffer\r\n *\r\n * @param {string} str - data string to convert\r\n *\r\n * @returns {ArrayBuffer | Uint8Array} charCode ArrayBuffer\r\n */\r\nfunction s2AB(str: string): ArrayBuffer | Uint8Array {\r\n    const buff = new Uint8Array(str.length);\r\n    for (let i = 0; i < str.length; i++) buff[i] = str.charCodeAt(i);\r\n    return buff;\r\n}\r\n\r\n/**\r\n * Converts ArrayBuffer to string\r\n *\r\n * @param {ArrayBuffer | Uint8Array} buff - charCode ArrayBuffer to convert\r\n *\r\n * @returns {string} data string\r\n */\r\nfunction AB2s(buff: ArrayBuffer | Uint8Array): string {\r\n    if (buff instanceof ArrayBuffer) buff = new Uint8Array(buff);\r\n    return String.fromCharCode.apply(String, buff);\r\n}\r\n\r\n/*\r\nexport function algHSsign(bits: number) {\r\n    return function sign(thing: string, secret: string): string {\r\n        const hmac = createHmac('sha' + bits, secret);\r\n        return b2bu(hmac.update(thing).digest('base64'));\r\n    }\r\n}\r\n\r\nexport function algHSverify(bits: number) {\r\n    return function verify(thing: string, signature: string, secret: string): boolean {\r\n        return signature === algHSsign(bits)(thing, secret);\r\n    }\r\n}\r\n\r\nexport function algRSsign(bits: number) {\r\n    return function sign(thing: string, privateKey: string): string {\r\n        const rsaSign = createSign('RSA-SHA' + bits);\r\n        return b2bu(rsaSign.update(thing).sign(privateKey, 'base64'));\r\n    }\r\n}\r\n\r\nexport function algRSverify(bits: number) {\r\n    return function verify(thing: string, signature: string, publicKey: string): boolean {\r\n        signature = bu2b(signature);\r\n        const rsaVerify = createVerify('RSA-SHA' + bits);\r\n        rsaVerify.update(thing);\r\n        return rsaVerify.verify(publicKey, signature, 'base64');\r\n    }\r\n}*/\r\n\r\n/**\r\n * Async function inspired by createHmac in crypto (used WebCrypto Api supported by most browsers)\r\n *\r\n */\r\n\r\nexport async function createHmac(name: string, secret: string): Promise<any> {\r\n    if (webCryptoSubtle) {\r\n        const keyData = s2AB(secret);\r\n        return await webCryptoSubtle.importKey(\r\n            'raw',\r\n            keyData,\r\n            { name: 'HMAC', hash: { name: name } },\r\n            true,\r\n            ['sign']\r\n        ).then(key => {\r\n            return {\r\n                _key: key,\r\n                update: async function (thing): Promise<ArrayBuffer> {\r\n                    return await webCryptoSubtle.sign(\r\n                        'HMAC',\r\n                        key,\r\n                        s2AB(thing)\r\n                    )\r\n                }\r\n            }\r\n        })\r\n    } else {\r\n        return !!crypto && crypto.createHmac ? Promise.resolve(crypto.createHmac(name.replace('SHA-', 'sha'), secret)) : Promise.reject(webCrypto);\r\n    }\r\n}\r\n\r\n/**\r\n * Algorithm HMAC sign generator\r\n *\r\n */\r\nexport function algHSsign(bits: number) {\r\n    /**\r\n     * Algorithm HMAC signer\r\n     *\r\n     */\r\n    return async function sign(thing: string, secret: string): Promise<string> {\r\n        const hmac = await createHmac('SHA-' + bits, secret);\r\n        return Promise.resolve(webCryptoSubtle ? s2bu(AB2s(hmac && await hmac.update(thing))) : b2bu(hmac && hmac.update(thing).digest('base64')));\r\n    }\r\n}\r\n\r\n/**\r\n * Algorithm HMAC verify generator\r\n *\r\n */\r\nexport function algHSverify(bits: number) {\r\n    /**\r\n     * Algorithm HMAC verifier\r\n     *\r\n     */\r\n    return async function verify(thing: string, signature: string, secret: string): Promise<boolean> {\r\n        return await algHSsign(bits)(thing, secret) === signature;\r\n    }\r\n}\r\n\r\nexport function RS2AB(secret: string) : ArrayBuffer | Uint8Array  {\r\n    if (typeof secret !== 'string') {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n    const lines = secret.split('\\n'),\r\n        ignoreLines = [\r\n        '-BEGIN RSA PRIVATE KEY-',\r\n        '-BEGIN RSA PUBLIC KEY-',\r\n        '-BEGIN PUBLIC KEY-',\r\n        '-END PUBLIC KEY-',\r\n        '-END RSA PRIVATE KEY-',\r\n        '-END RSA PUBLIC KEY-'\r\n    ], result = lines.map(line => line.trim()).filter(line =>\r\n        line.length &&\r\n        !ignoreLines.some(ign => line.toUpperCase().indexOf(ign) > -1)\r\n    ).join('');\r\n    if(result.length) {\r\n        return s2AB(result);\r\n    } else {\r\n        throw new Error(ILLEGAL_ARGUMENT);\r\n    }\r\n}\r\n/*\r\nexport async function createSign(name: string, secret: string): Promise<any> {\r\n    if (webCryptoSubtle) {\r\n        const keyData = RS2AB(secret);\r\n        return await webCryptoSubtle.importKey(\r\n            'raw',\r\n            keyData,\r\n            { name: 'HMAC', hash: { name: name } },\r\n            true,\r\n            ['sign']\r\n        ).then(key => {\r\n            return {\r\n                _key: key,\r\n                update: async function (thing): Promise<ArrayBuffer> {\r\n                    return await webCryptoSubtle.sign(\r\n                        'HMAC',\r\n                        key,\r\n                        s2AB(thing)\r\n                    )\r\n                }\r\n            }\r\n        })\r\n    } else {\r\n        return !!crypto && crypto.createSign ? Promise.resolve(crypto.createSign(name)) : Promise.reject(webCrypto);\r\n    }\r\n}\r\n\r\nexport async function algRSsign(bits: number) {\r\n    return function sign(thing: string, privateKey: string): string {\r\n        const rsaSign = await createSign('RSA-SHA' + bits);\r\n        return b2bu(rsaSign.update(thing).sign(privateKey, 'base64'));\r\n    }\r\n}\r\n\r\nexport function algRSverify(bits: number) {\r\n    return function verify(thing: string, signature: string, publicKey: string): boolean {\r\n        signature = bu2b(signature);\r\n        const rsaVerify = crypto.createVerify('RSA-SHA' + bits);\r\n        rsaVerify.update(thing);\r\n        return rsaVerify.verify(publicKey, signature, 'base64');\r\n    }\r\n}\r\n*/\r\n\r\n/**\r\n * Universal algorithm verifier\r\n *\r\n */\r\nexport async function algVerify(algorithm: string, thing: string, signature: string, secret: string): Promise<boolean> {\r\n    if (typeof algorithm !== 'string' || algorithm.length < 4) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n    const algo = algorithm.toLowerCase();\r\n\r\n    if (algo === 'none') {\r\n        return signature === '';\r\n    }\r\n\r\n    const type = algo.slice(0, 2), bits = parseInt(algo.slice(2));\r\n    if (isNaN(bits) || ([256, 384, 512].indexOf(bits) < 0)) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n\r\n    switch (type) {\r\n        //case 'rs':\r\n            //return await algRSverify(bits)(thing, signature, secret);\r\n        case 'hs':\r\n            return await algHSverify(bits)(thing, signature, secret);\r\n        default:\r\n            throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n}\r\n\r\n/**\r\n * Universal algorithm signer\r\n *\r\n */\r\nexport async function algSign(algorithm: string, thing: string, secret: string): Promise<string> {\r\n    if (typeof algorithm !== 'string' || algorithm.length < 4) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n    const algo = algorithm.toLowerCase();\r\n\r\n    if (algo === 'none') {\r\n        return '';\r\n    }\r\n\r\n    const type = algo.slice(0, 2), bits = parseInt(algo.slice(2));\r\n    if (isNaN(bits) || ([256, 384, 512].indexOf(bits) < 0)) {\r\n        throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n\r\n    switch (type) {\r\n        //case 'rs':\r\n            //return await algRSsign(bits)(thing, secret);\r\n        case 'hs':\r\n            return await algHSsign(bits)(thing, secret);\r\n        default:\r\n            throw new Error(UNSUPPORTED_ALGORITHM);\r\n    }\r\n}\r\n\r\nexport async function jwtVerify(jwtStr: string, secret: string): Promise<boolean> {\r\n    const jwt = jwtSplit(jwtStr),\r\n        header = s2J(bu2s(jwt.header)),\r\n        thing = jwt.header + '.' + jwt.payload;\r\n    return await algVerify(header.alg, thing, jwt.signature, secret);\r\n}\r\n\r\nexport async function jwtSign(jwtStr: string, secret: string): Promise<string> {\r\n    const jwt = jwtSplit(jwtStr),\r\n        header = s2J(bu2s(jwt.header)),\r\n        thing = jwt.header + '.' + jwt.payload;\r\n    return await algSign(header.alg, thing, secret);\r\n}\r\n\r\nexport async function resignJwt(jwtStr: string, secret: string, alg?: string): Promise<string> {\r\n    const jwt = jwtDecode(jwtStr);\r\n    if(!!alg) jwt.header.alg = alg;\r\n    jwt.signature = await jwtSign(jwt.toString(), secret);\r\n    return jwt.toString();\r\n}\r\n\r\n/**\r\n * Used for testing only\r\n *\r\n * @hidden\r\n */\r\nexport function cryptoType(): string {\r\n    return crypto ? crypto['type'] || 'crypto-node' : 'undefined';\r\n}\r\n\r\nconst jwsJsDecode = {\r\n    JwtDecode,\r\n    JwtSplit,\r\n    b2bu,\r\n    b2s,\r\n    bu2b,\r\n    bu2s,\r\n    isGzip,\r\n    jwtDecode,\r\n    jwtSplit,\r\n    s2b,\r\n    s2bu,\r\n    s2zbu,\r\n    unzip,\r\n    zbu2s,\r\n    zip,\r\n    algHSsign,\r\n    algHSverify,\r\n    //algRSsign,\r\n    //algRSverify,\r\n    algVerify,\r\n    algSign,\r\n    jwtVerify,\r\n    jwtSign,\r\n    resignJwt,\r\n    cryptoType\r\n};\r\n\r\nexport default jwsJsDecode;\r\n"],"names":[],"mappings":"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"}